class Graph:

    def __init__(self, N: int):
        self.N = N
        self.d = [10000000]*N
        for i in range(0, N):
            self.d[i] = [10000000] * N
        self.lab = [[0]*N]*N

    def is_Inside(self, x, y: int) -> bool:
        if x < 0:
            return False
        if y < 0:
            return False
        if x >= self.N:
            return False
        if y >= self.N:
            return False
        return True


class Coord:
    def __init__(self, x, y: int):
        self.x = x
        self.y = y


N = 14
g = Graph(N)
g.lab = [
    ["#", "#", "#", "#", "#", "#", "#", "#", "E", "#", "#", "#", "#", "#"],
    ["#", ".", "#", ".", "#", "#", "#", "#", ".", ".", "#", "#", "#", "#"],
    ["#", ".", ".", ".", "#", "#", "#", "#", "#", ".", "#", "#", "#", "#"],
    ["S", ".", ".", "#", ".", ".", "#", "#", "#", ".", ".", ".", ".", "#"],
    ["#", "#", ".", ".", ".", "#", "#", "#", "#", "#", "#", ".", "#", "#"],
    ["#", "#", "#", ".", ".", ".", ".", ".", ".", ".", ".", ".", "#", "#"],
    ["#", "#", "#", ".", "#", "#", "#", ".", "#", "#", "#", ".", ".", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
    ["#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#"],
]

queue = []
for i in range(N):
    for j in range(N):
        """Поиск стартовой точки"""
        if g.lab[i][j] == "S":
            g.d[i][j] = 0
            queue.append(Coord(i, j))
dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]
while queue:
    x = queue[-1].x
    y = queue[-1].y
    queue.pop()
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if g.is_Inside(nx, ny):  # если координаты не выходят за рамки лабиринта
            if g.lab[nx][ny] == '.':  # иесли ячейка пустая
                if g.d[nx][ny] == 10000000:  # если координаты еще не посещены
                    # устанавливаем растояние до текущей вершины
                    g.d[nx][ny] = g.d[x][y] + 1
                    queue.append(Coord(nx, ny))  # добавляем вершину в очередь

            else:
                if g.lab[nx][ny] == 'E':
                    print("Длина пути", g.d[x][y] + 1)
                    break
